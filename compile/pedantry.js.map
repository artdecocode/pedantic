{
"version":3,
"file":"compile/pedantry.js",
"lineCount":171,
"mappings":"A;;;;;;;AACO,MAAM,CAOX,KAAAA,CAPW,CAAA,GAeTC,IAfG;ACAA,MAAM,CAiBX,iBAAAC,CAjBW,EAyCX,MAAAC,CAzCW,EAqDX,QAAAC,CArDW,CAAA,GAgFTC,EAhFG;ACAA,MAAM,CAEX,YAAAC,CAFW,CAAA,GAOTC,MAPG;ACAA,MAAM,CAKX,SAAAC,CALW,CAAA,GA+BTC,IA/BG;ACYA,MAAMC,IAAkB,CAACC,CAAD,EAAQC,CAAA,GAAO,CAAf,EAAkBC,CAAA,GAAU,CAAA,CAA5B,CAAAH,IAAsC;AACnE,MAAa,CAAb,KAAIE,CAAJ,IAAkB,CAACC,CAAnB;AACE,WAAOF,CAAP;AADF;AAGMG,GAAAA,GAAaH,CAAAI,MAAA,CACV,IADU,EACJF,CAAA,GAAUD,CAAV,GAAiB,CAAjB,GAAqBI,IAAAA,EADjB,CAAbF;AAEN,SAAID,CAAJ,GAC2BC,CAnBdG,CAmBcH,CAnBRI,OAAND,GAAqB,CAArBA,CAkBb,GAI6BH,CAnBOK,MAAAC,CAmBKR,CAnBLQ,CAoB3BpB,KAAA,CAAW,IAAX,CALT;AANmE,CAA9D,EAsBMqB,IAAgB,CAACV,CAAD,EAAQW,CAAA,GAAc,CAAA,CAAtB,CAAAD,IACNX,CAAAa,CAAgBZ,CAAhBY,EAAuB,CAAvBA,IAA4BD,CAAA,GAAc,CAAd,GAAkB,CAA9CC,EAvBhB,EA4CMC,IAA0BC,CAADD,IAAU;AAC9C,GAAM,CAAE,OAAQ,CAAE,OAAAE,CAAF,CAAV,CAAN,GAA+BD,CAA/B;AACA,SAAOC,CAAP;AAF8C,CA5CzC;ACZA,MAAM,CAOX,QAAAC,CAPW,CAAA,GAkBTC,EAlBG;ACCP,MAAMC,IAAmB,yBAAzB,EACMC,IAAY,uGADlB,EAGMC,IAAUJ,CAAA,EAHhB,EAYMK,IAAcrB,CAADqB,IAAoB;AACrC,QAAM,CACJ,OAAAC,CAAA,GAAS,CAAA,CADL,EACY,eAAAC,CAAA,GAAiB,CAAC,SAAD,CAD7B,CAAA,GAES,EAFf,EAGMC,IAAID,CAAAlC,KAAA,CAAoB,GAApB,CAHV,EAIMoC,IAAK,IAAIC,MAAJ,CAAWP,CAAAQ,OAAAC,QAAA,CAAyB,iBAAzB,EAA4CJ,CAA5C,CAAX,CAJX;AAMA,SAAOxB,CAAA4B,QAAA,CAAc,KAAd,EAAqB,GAArB,CAAAxB,MAAA,CACE,IADF,CAAAyB,OAAA,CAEGC,CAAA,IAAK;AACLC,KAAAA,GAAcD,CAAAE,MAAA,CAAQd,CAAR,CAAda;AACN,QAAoB,IAApB,KAAIA,CAAJ,IAA4B,CAACA,CAAA,CAAY,CAAZ,CAA7B;AACE,aAAO,CAAA,CAAP;AADF;AAIMC,KAAAA,GAAQD,CAAA,CAAY,CAAZ,CAARC;AAGN,WAAIA,CAAAC,SAAA,CAAe,uCAAf,CAAJ,IACED,CAAAC,SAAA,CAAe,0CAAf,CADF,GAES,CAAA,CAFT,GAKO,CAACR,CAAAS,KAAA,CAAQF,CAAR,CALR;AATW,GAFR,CAAAH,OAAA,CAkBGC,CAAA,IAAKA,CAAAK,KAAA,EAlBR,CAAAC,IAAA,CAmBAN,CAAA,IACCR,CAAJ,GACSQ,CAAAF,QAAA,CAAUV,CAAV,EAA4B,CAACmB,CAAD,EAAIC,CAAJ,CAAA,IAAWD,CAAAT,QAAA,CAAUU,CAAV,EAAcA,CAAAV,QAAA,CAAWR,CAAX,EAAoB,GAApB,CAAd,CAAvC,CADT,GAIOU,CAxBJ,CAAAzC,KAAA,CA0BC,IA1BD,CAAP;AAPqC,CAZvC;ACSOkD,QAASA,EAAY,CAACC,CAAD,EAAcC,CAAd,EAA0BC,CAAA,GAAS,CAAA,CAAnC,CAA0C;AA8BpE,SAxBAC,QAAW,CAACC,CAAD,CAAiB;AAC1B,QAAM7B,IAASF,CAAA,CAAuBgC,SAAvB,CAAf,EACM,CAAE,MAAOC,CAAT,CAAA,GAA4BC,KAAJ,EAD9B;AAEA,UAAMC,IH0BgBjD,CAAAiD,CG1BqBF,CH0BrBE,EAAuB,CAAvBA,EAA0B,CAAA,CAA1BA,CG1BtB,EAEMC,IAAU,CADVC,CACU,GADAN,CACA,YAD0BG,KAC1B,IAAUH,CAAAK,QAAV,GAAmCL,CAFnD;AAMMO,KAAAA,GAAe,CHwBiBC,UG1BDH,CH0BCG,EGxBjB,EAEnB,GAHgC,IAG5B,KAHiBrC,CAGjB,IAHoCyB,CAGpC,KAHoDzB,CAGpD,IAAkB2B,CAAlB,GAA2B,CAACD,CAAD,CAA3B,GAA0C,CAC5CO,CAD4C,EAE5CP,CAF4C,CAF3B,CAAApD,KAAA,CAMd,IANc,CAAf8D;AAQAnD,KAAAA,GDgBKqB,CChBG,CAAW8B,CAAX,CAARnD;AAIN,WAA6BqD,MAAAC,OAAA,CAFnBJ,CAAAK,GAAUX,CAAVW,GAA+BR,KAAJ,EAER,EAHVS,CAAEP,QAAAA,CAAFO,EAAWxD,MAAAA,CAAXwD,CAGU,CAA7B;AArB0B,GAwB5B;AA9BoE;A,CCFvDC,QAASA,EAAM,CAAC9C,CAAD,CAAc;AAC1C,MAAM,CAAE,MAAAX,CAAF,CAAA,GAAgB+C,KAAJ,EAAlB;AACA,QAAMhC,IAASF,CAAA,CAAuBgC,SAAvB,CAAf;AACMJ,GAAAA,GAAa/B,CAAA,CAAcV,CAAd,EAAqBW,CAArB,CAAb8B;AAEN,SAAOF,CAAA,CAAaxB,CAAb,EAAqB0B,CAArB,EAAiC9B,CAAjC,CAAP;AAL0C;A,CCP5C+C,QAASA,EAAkB,CAACnD,CAAD,EAASoD,CAAT,CAAY;AACrC,MAAIA,CAAJ,GAAQpD,CAAR,GAAiB,CAAjB;AACE,UAAUwC,KAAJ,CAAU,+CAAV,CAAN;AADF;AADqC;AAaxBa,cAAeA,EAAW,CAACC,CAAD,EAAK/C,CAAL,EAAWgD,CAAX,CAAyB;AAChE,QAAMC,IAAKN,CAAA,CAAO,CAAA,CAAP,CAAX;AACA,MAAkB,UAAlB,KAAI,MAAOI,EAAX;AACE,UAAUd,KAAJ,CAAU,0BAAV,CAAN;AADF;AAGA,QAAM,CAAE,OAAQiB,CAAV,CAAA,GAAuBH,CAA7B;AACA,MAAI,CAACG,CAAL;AACE,UAAUjB,KAAJ,CAAU,yCAAV,CAAN;AADF;AA0BA,SAtBYkB,MAAM,IAAIC,OAAJ,CAAY,CAACC,CAAD,EAAUC,CAAV,CAAA,IAAoB;AAChD,UAAMzB,IAAK,CAAC0B,CAAD,EAAMJ,CAAN,CAAAtB,IACL0B,CAAJ,IACQC,CACC,GADOP,CAAA,CAAGM,CAAH,CACP,EAAAD,CAAA,CAAOE,CAAP,CAFT,IAIOH,CAAA,CAAQL,CAAR,IAAwBG,CAAxB,CALT;AAQA,QAAIM,IAAU,CAAC5B,CAAD,CAAd;AAEI6B,SAAAC,QAAA,CAAc3D,CAAd,CAAJ,IACEA,CAAA4D,QAAA,CAAa,CAACC,CAAD,EAAMhB,CAAN,CAAA,IAAY;AACvBD,OAAA,CAAmBM,CAAnB,EAA6BL,CAA7B,CAAA;AADuB,KAAzB,CAGA,EAAAY,CAAA,GAAW,CAAC,GAAGzD,CAAJ,EAAU6B,CAAV,CAJb,IAK0C,CAL1C,GAKW6B,KAAAvE,KAAA,CAAW4C,SAAX,CAAAtC,OALX,KAMEmD,CAAA,CAAmBM,CAAnB,EAA6B,CAA7B,CACA,EAAAO,CAAA,GAAU,CAACzD,CAAD,EAAO6B,CAAP,CAPZ,CAAA;AASAkB,KAAA,CAAG,GAAGU,CAAN,CAAA;AApBgD,GAAhC,CAsBlB;AAhCgE;A,CCLlEK,cAAeA,EAAU,CAACC,CAAD,EAAUC,CAAV,CAAsB;AACvCC,GAAAA,GAAYD,CAAA1C,IAAA,CAAe,KAAO4C,EAAP,IAAwB;AACvD,UAAM1F,IAAOD,CAAA,CAAKwF,CAAL,EAAcG,CAAd,CAAb;AAEA,WAAO,CACLxF,MAFSyF,MAAMrB,CAAA,CAAYpE,CAAZ,EAAmBF,CAAnB,CACV,EAELA,KAAAA,CAFK,EAGL0F,aAAAA,CAHK,CAAP;AAHuD,GAAvC,CAAZD;AAUN,SADYd,MAAMC,OAAAgB,IAAA,CAAYH,CAAZ,CAClB;AAX6C;AAsB/C,MAAMI,IAAcC,CAAAD,IAAYC,CAAA5F,MAAA2F,YAAA,EAAhC,EASME,IAAiBD,CAAAC,IAAY,CAACD,CAAA5F,MAAA2F,YAAA,EATpC;AAiDeG,cAAeA,EAAgB,CAACT,CAAD,CAAU;AACtD,MAAI,CAACA,CAAL;AACE,UAAU9B,KAAJ,CAAU,wCAAV,CAAN;AADF;AAIA,MAAI,CAACoC,CADMF,MAAMrB,CAAA,CAAYpE,CAAZ,EAAmBqF,CAAnB,CACZM,aAAA,EAAL;AAGE,UAFMd,CAEAA,GAFUtB,KAAJ,CAAU,yBAAV,CAENsB,EADNA,CAAAkB,KACMlB,GADK,SACLA,EAAAA,CAAN;AAHF;AAKA,MAAMmB,IAAqC,MAAM5B,CAAA,CAAYnE,CAAZ,EAAqBoF,CAArB,CAAjD;AACMY,GAAAA,GAAM,MAAMb,CAAA,CAAWC,CAAX,EAAoBW,CAApB,CAAZC;AAEAC,GAAAA,GAAcD,CAAA5D,OAAA,CAAWsD,CAAX,CAAdO;AAGAC,GAAAA,GAFiBF,CAAA5D,OAAA+D,CAAWP,CAAXO,CAETC,OAAA,CAAsB,CAACC,CAAD,EAAMC,CAAN,CAAA,IAAkB;AApDpD,QAAA,IAqDqBA,CAtDnBvG,MAAA2F,YAAA,EAAJ,GACS,WADT,GAsDuBY,CAnDnBvG,MAAAwG,OAAA,EAAJ,GACS,MADT,GAmDuBD,CAhDnBvG,MAAAyG,eAAA,EAAJ,GACS,cADT,GAP4B,IAAA,EAE1B;AAsDA,WAAO,CACL,GAAGH,CADE,EAEL,CAACC,CAAAf,aAAD,EAAwB,CACtBkB,KAJSA,CAGa,CAFnB,CAAP;AAFoD,GAAxC,EAQX,EARW,CAARP;AAUAQ,GAAAA,GAAO,MAAMT,CAAAG,OAAA,CAAmB,KAAM,CAACC,CAAD,EAAM,CAAE,KAAAxG,CAAF,EAAQ,aAAA0F,CAAR,CAAN,CAAN,IAAuC;AACrEf,KAAAA,GAAM,MAAM6B,CAAZ7B;AACAmC,KAAAA,GAAY,MAAMd,CAAA,CAAiBhG,CAAjB,CAAlB8G;AACN,WAAO,CACL,GAAGnC,CADE,EAEL,CAACe,CAAD,EAAgBoB,CAFX,CAAP;AAH2E,GAA1D,EAOhB,EAPgB,CAAbD;AAaN,SAAO,CACLE,QALcA,CACd,GAAGV,CADWU,EAEd,GAAGF,CAFWE,CAIT,EAELH,KAAM,WAFD,CAAP;AAvCsD;A,CC1DxD,MAAMI,IAAU,CAACC,CAAD,EAAQC,CAAR,CAAAF,IACPC,CAAAE,KAAA,CAAWC,CAAA,IAAKA,CAAL,IAAUF,CAArB,CADT,EAQaG,IAAU,CAAChB,CAAD,EAAQiB,CAAR,CAAAD,IAAoB;AACzC,QAAME,IAAWP,CAAA,CAAQX,CAAR,EAAe,UAAf,CAAjB,EACMmB,IAAYR,CAAA,CAAQX,CAAR,EAAe,WAAf,CADlB,EAGMoB,IAAW,CAAC,UAAD,EAAa,WAAb,CAHjB;AAOMC,GAAAA,GAFWrB,CAAA9D,OAAAoF,CAAaC,CAAA,IAAK,CAACH,CAAA9E,SAAA,CAAkBiF,CAAlB,CAAnBD,CAEFE,KAAA,CAAc,CAACT,CAAD,EAAIU,CAAJ,CAAA,IAAU;AAC/BnD,KAAAA,GAAMyC,CAAAW,cAAA,CAAgBD,CAAhB,EAAmB/G,IAAAA,EAAnB,EAA8B,CAAEiH,QAAS,CAAA,CAAX,CAA9B,CAANrD;AACN,WAAI2C,CAAJ,GAAoB,CAAC3C,CAArB,GACOA,CADP;AAFqC,GAAxB,CAAT+C;AAMN,SAAIH,CAAJ,IAAgBC,CAAhB,GACS,CACL,UADK,EAEL,GAAGE,CAFE,EAGL,WAHK,CADT,GAOIH,CAAJ,GACS,CACL,UADK,EAEL,GAAGG,CAFE,CADT,GAMIF,CAAJ,GACS,CACL,GAAGE,CADE,EAEL,WAFK,CADT,GAMOA,CAnBP;AAdyC,CAR3C;AChBA,MAAMO,IAAM1H,CAAA,CAAS,UAAT,CAAZ,EAEM2H,IAAaA,KAAM,CAAC,CACxB,OAAA5H,CADwB,EAChB,OAAA+B,CADgB,EACR,KAAArC,CAAA,GAAO,GADC,EACI,QAAA+G,CAAA,GAAU,EADd,EACkB,QAAAO,CAAA,GAAU,CAAA,CAD5B,EAExB,UAAAa,CAFwB,EAEb,gBAAAC,CAFa,EAEI,aAAAC,CAFJ,CAAD,CAANH,IAGb;AACJ,MAAMI,IAAIvE,MAAAwE,KAAA,CAAYxB,CAAZ,CAAV;AAIMyB,GAAAA,GAAO,MAFAnB,CAAAkB,CAAQD,CAARC,EAAWjB,CAAXiB,CAEMhC,OAAA,CAAY,KAAM,CAACC,CAAD,EAAMiC,CAAN,CAAN,IAAqB;AAC9CC,KAAAA,GAAY,MAAMlC,CAAlBkC;AACJ,UAAM,CAAE,KAAA9B,CAAF,EAAQ,QAASpB,CAAjB,CAAA,GAAgCuB,CAAA,CAAQ0B,CAAR,CAAtC,EACME,IAAU5I,CAAA,CAAKC,CAAL,EAAWyI,CAAX,CADhB;AAGA,QAAIG,CAAJ;AACY,UAAZ,IAAIhC,CAAJ,GACuByB,CADvB,IACuCI,CAAAI,WAAA,CAAgB,GAAhB,CADvC,KAEqBD,CAFrB,GAEyB,MAAME,CAAA,CAAY,CACvCxI,OAAAA,CADuC,EAC/B+B,OAAAA,CAD+B,EACvBrC,KAAM2I,CADiB,EACRR,UAAAA,CADQ,EACGC,gBAAAA,CADH,CAAZ,CAF/B,IAKmB,WALnB,IAKWxB,CALX,KAMEgC,CANF,GAMM,MAAMV,CAAA,CAAW,CACnB5H,OAAAA,CADmB,EACX+B,OAAAA,CADW,EACHrC,KAAM2I,CADH,EACY5B,QAASvB,CADrB,EACiC8B,QAAAA,CADjC,EAEnBa,UAAAA,CAFmB,EAERC,gBAAAA,CAFQ,EAESC,aAAAA,CAFT,CAAX,CANZ,CAAA;AAYA,WADAK,CACA,GADaE,CACb;AAlBkD,GAAjC,EAmBhB,CAnBgB,CAAbJ;AAqBNP,GAAA,CAAI,mBAAJ,EAAyBjI,CAAzB,EAA+BwI,CAA/B,CAAA;AACA,SAAOA,CAAP;AA3BI,CALN,EAuCMM,IAAcA,KAAOC,EAAPD,IAAmB;AACrC,QAAM,CACJ,OAAAxI,CADI,EACI,OAAA+B,CADJ,EACY,KAAArC,CADZ,EACkB,UAAAmI,CADlB,EAC6B,gBAAAC,CAD7B,CAAA,GAEFW,CAFJ,EAGMC,IAAWjJ,CAAA,CAAKsC,CAAL,EAAarC,CAAb,CAHjB;AAIAM,GAAA2I,KAAA,CAAY,MAAZ,EAAoBjJ,CAApB,CAAA;AACImI,GAAJ,IAAiB,CAAC7H,CAAA4I,EAAlB,KACMd,CAAJ,GACE9H,CAAA6I,KAAA,CAAY,CAAEjC,KAAM,WAAR,EAAqBkC,KAAMjB,CAA3B,CAAZ,CADF,GAGE7H,CAAA6I,KAAA,CAAYhB,CAAZ,CAJJ;AAOMK,GAAAA,GAAO,MAAM,IAAI5D,OAAJ,CAAY,CAACyE,CAAD,EAAInH,CAAJ,CAAA,IAAU;AACvC,QAAI0G,IAAI,CAAR;AACA,UAAMU,IAAKrJ,CAAA,CAAiB+I,CAAjB,CAAX;AACAM,KAAAC,GAAA,CAAM,MAAN,EAAeC,CAAD,IAAO;AACnBZ,OAAA,IAAKY,CAAAC,WAAL;AADmB,KAArB,CAAAF,GAAA,CAEM,OAFN,EAEgBxE,CAAD,IAAS;AACtB7C,OAAA,CAAE6C,CAAF,CAAA;AADsB,KAFxB,CAAAwE,GAAA,CAIM,OAJN,EAIe,EAAA,IAAM;AACnBF,OAAA,CAAET,CAAF,CAAA;AADmB,KAJrB,CAAA;AAOA,QAAIR,CAAJ;AACEkB,OAAAC,GAAA,CAAM,MAAN,EAAeH,CAAD,IAAU;AACtB9I,SAAA6I,KAAA,CAAY,CAAEjC,KAAM8B,CAAR,EAAkBI,KAAM,GAAGA,CAAH,EAAxB,CAAZ,CAAA;AADsB,OAAxB,CAAA;AADF;AAKEE,OAAAI,KAAA,CAAQpJ,CAAR,EAAgB,CAAEqJ,IAAK,CAAA,CAAP,CAAhB,CAAA;AALF;AAVuC,GAAtB,CAAbnB;AAkBNlI,GAAA4I,EAAA,GAAqB,CAAA,CAArB;AACAjB,GAAA,CAAI,iBAAJ,EAAuBe,CAAvB,EAAiCR,CAAjC,CAAA;AACA,SAAOA,CAAP;AAjCqC,CAvCvC;AA6Ee,KAAMoB,EAAN,QAAuBvJ,EAAvB;AAMb,aAAW,CAACgC,CAAD,EAAS0G,CAAA,GAAU,EAAnB,CAAuB;AAChC,UAAM,CACJ,QAAAzB,CAAA,GAAU,CAAA,CADN,EAEJ,WAAAuC,CAAA,GAAa,CAAA,CAFT,EAGJ,aAAAC,CAAA,GAAe,CAAA,CAHX,EAIJ,gBAAA1B,CAAA,GAAkB,CAAA,CAJd,EAKJ,aAAAC,CAAA,GAAe,CAAA,CALX,CAAA,GAMFU,CANJ;AAOA,SAAA,CAAM,CACJgB,WAAY3B,CADR,CAAN,CAAA;AAGA,QAAID,CAAJ;AACI0B,KAAJ,GAAgB1B,CAAhB,GAA4B,IAA5B,GACS2B,CADT,KACuB3B,CADvB,GACmC,MADnC,CAAA;AAEA,QAAAe,EAAA,GAAmB,CAAA,CAAnB;AACE,UAAM,EAAN,IAAY;AACZ,UAAInC,CAAJ;AACA,SAAI;AACF,SAAC,CAAE,QAAAA,CAAF,CAAD,GAAe,MAAMf,CAAA,CAAiB3D,CAAjB,CAArB;AADE,OAEF,QAAO0C,CAAP,CAAY;AAEZ,YAAAkE,KAAA,CAAU,OAAV,EADcxF,KAAJQ,CAAUc,CAAApB,QAAVM,CACV,CAAA;AAFY;AAId,SAAI;AACF,cAAMiE,CAAA,CAAW,CACf5H,OAAQ,IADO,EAEf+B,OAAAA,CAFe,EAGf0E,QAAAA,CAHe,EAIfO,QAAAA,CAJe,EAKfa,UAAAA,CALe,EAMfC,gBAAAA,CANe,EAOfC,aAAAA,CAPe,CAAX,CAAN;AADE,OAUF,QAAOtD,CAAP,CAAY;AACZ,YAAAkE,KAAA,CAAU,OAAV,EAAmBlE,CAAnB,CAAA;AADY,OAVd,QAYU;AACR,YAAA4E,IAAA,EAAA;AADQ;AApBE,KAAZ,CAAD,EAAA;AAf+B;AANrB;A,CCjFfK,MAAAC,QAAA,GAAiBL,CAAjB;;",
"sources":["node_modules/path/index.js","node_modules/fs/index.js","node_modules/stream/index.js","node_modules/util/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/makepromise/src/index.js","node_modules/@wrote/read-dir-structure/src/index.js","src/lib/index.js","src/index.js","src/depack.js"],
"sourcesContent":["export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","export default util\nexport const {\n  TextDecoder,\n  TextEncoder,\n  callbackify,\n  debug,\n  debuglog,\n  deprecate,\n  error,\n  format,\n  getSystemErrorName,\n  inherits,\n  inspect,\n  isArray,\n  isBoolean,\n  isBuffer,\n  isDate,\n  isError,\n  isFunction,\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isObject,\n  isPrimitive,\n  isRegExp,\n  isString,\n  isSymbol,\n  isUndefined,\n  log,\n  print,\n  promisify,\n  puts,\n} = util","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","import erotic from 'erotic'\n\nfunction checkArgumentIndex(length, i) {\n  if (i > length - 2) {\n    throw new Error('Function does not accept that many arguments.')\n  }\n}\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn !== 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error('Function does not accept any arguments.')\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      args.forEach((arg, i) => {\n        checkArgumentIndex(fnLength, i)\n      })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      checkArgumentIndex(fnLength, 0)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","import { lstat, readdir } from 'fs'\nimport makePromise from 'makepromise'\nimport { join } from 'path'\n\n/**\n * Update information about directory's content with lstat.\n * @param {string} dirPath Path to the root directory\n * @param {!Array<string>} dirContent\n * @returns {Promise<Array<_readDirStructure.File>>} An array with file objects.\n */\nasync function lstatFiles(dirPath, dirContent) {\n  const readFiles = dirContent.map(async (relativePath) => {\n    const path = join(dirPath, relativePath)\n    const ls = await makePromise(lstat, path)\n    return {\n      lstat: ls,\n      path,\n      relativePath,\n    }\n  })\n  const res = await Promise.all(readFiles)\n  return res\n}\n\n/**\n * Check if lstat result is a directory\n * @param {_readDirStructure.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is a directory\n */\nconst isDirectory = lstatRes => lstatRes.lstat.isDirectory()\n/**\n * Check if lstat result is not a directory\n * @param {_readDirStructure.File} lstatRes\n * @param {!fs.Stats} lstatRes.lstat The stats of the item.\n * @param {string} lstatRes.path The full path of the item.\n * @param {string} lstatRes.relativePath The name of the item.\n * @returns {boolean} true if is not a directory\n */\nconst isNotDirectory = lstatRes => !lstatRes.lstat.isDirectory()\n\nconst getType = (lstatRes) => {\n  if (lstatRes.lstat.isDirectory()) {\n    return 'Directory'\n  }\n  if (lstatRes.lstat.isFile()) {\n    return 'File'\n  }\n  if (lstatRes.lstat.isSymbolicLink()) {\n    return 'SymbolicLink'\n  }\n}\n\n/**\n * Read a directory, and return its structure as an object. Only `Files`, `Directories` and `Symlinks` are included!\n * @param {string} dirPath Path to the directory.\n * @returns {Promise<_readDirStructure.DirectoryStructure>} An object reflecting the directory structure.\n * @example\n```js\nconst res = await readDirStructure('dir')\n// result:\n{\n  type: 'Directory',\n  content: {\n    'data.txt': {\n      type: 'File'\n    },\n    subdir: {\n      type: 'Directory',\n      content: {\n        'data-ln.txt': {\n          type: 'SymbolicLink'\n        },\n      }\n    }\n  }\n}\n```\n */\nexport default async function readDirStructure(dirPath) {\n  if (!dirPath) {\n    throw new Error('Please specify a path to the directory')\n  }\n  const ls = await makePromise(lstat, dirPath)\n  if (!ls.isDirectory()) {\n    const err = new Error('Path is not a directory')\n    err.code = 'ENOTDIR'\n    throw err\n  }\n  const dir = /** @type {!Array<string>} */ (await makePromise(readdir, dirPath))\n  const lsr = await lstatFiles(dirPath, dir)\n\n  const directories = lsr.filter(isDirectory) // reduce at once\n  const notDirectories = lsr.filter(isNotDirectory)\n\n  const files = notDirectories.reduce((acc, current) => {\n    const type = getType(current)\n    return {\n      ...acc,\n      [current.relativePath]: {\n        type,\n      },\n    }\n  }, {})\n\n  const dirs = await directories.reduce(async (acc, { path, relativePath }) => {\n    const res = await acc\n    const structure = await readDirStructure(path)\n    return {\n      ...res,\n      [relativePath]: structure,\n    }\n  }, {})\n\n  const content = {\n    ...files,\n    ...dirs,\n  }\n  return {\n    content,\n    type: 'Directory',\n  }\n}\n\n/**\n * After running the `readDirStructure`, this function can be used to flatten the `content` output and return the list of all files (not including symlinks).\n * @param {!_readDirStructure.Content} content The recursive content of the directory.\n * @param {string} path The path to the directory.\n */\nexport const getFiles = (content, path) => {\n  let files = []\n  let dirs = []\n  Object.keys(content).forEach((key) => {\n    const { type } = content[key]\n    if (type == 'File') files.push(join(path, key))\n    else if (type == 'Directory') dirs.push(key)\n  })\n  const dirFiles = dirs.reduce((acc, dir) => {\n    const { content: c } =\n      /** @type {!_readDirStructure.Content} */ (content[dir])\n    const f = getFiles(c, join(path, dir))\n    return [...acc, ...f]\n  }, [])\n  return [...files, ...dirFiles]\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.File} File\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _readDirStructure.File\n * @prop {!fs.Stats} lstat The stats of the item.\n * @prop {string} path The full path of the item.\n * @prop {string} relativePath The name of the item.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.Content} Content The recursive content of the directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object<string, !_readDirStructure.DirectoryStructure>} _readDirStructure.Content The recursive content of the directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_readDirStructure.DirectoryStructure} DirectoryStructure A directory structure representation.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _readDirStructure.DirectoryStructure A directory structure representation.\n * @prop {string} [type] The type of the item.\n * @prop {!_readDirStructure.Content} [content] The recursive content if the item is a directory.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */\n","/**\n * Exclude items from the array\n * @param {!Array<!Array<string>, !Array<string>>} acc left to exclude, and non-excluded\n * @param {string} current\n */\nexport const excludeReducer = (acc, current) => {\n  const [ok, ex] = acc\n  let i\n  if (!ex.length || (i = ex.indexOf(current)) == -1) {\n    return [\n      [...ok, current],\n      ex,\n    ]\n  }\n  const before = ex.slice(0, i)\n  const after = ex.slice(i + 1, -1)\n  const newExcluded = [...before, ...after]\n  return [\n    ok,\n    newExcluded,\n  ]\n}\n\nconst hasFile = (array, file) => {\n  return array.some(a => a == file)\n}\n\n/**\n * @param {!Array<string>} files\n * @param {boolean} [reverse]\n */\nexport const getKeys = (files, reverse) => {\n  const hasIndex = hasFile(files, 'index.md')\n  const hasFooter = hasFile(files, 'footer.md')\n\n  const excluded = ['index.md', 'footer.md']\n\n  const included = files.filter(f => !excluded.includes(f))\n\n  const sorted = included.sort((a, b) => {\n    const res = a.localeCompare(b, undefined, { numeric: true })\n    if (reverse) return -res\n    return res\n  })\n\n  if (hasIndex && hasFooter) {\n    return [\n      'index.md',\n      ...sorted,\n      'footer.md',\n    ]\n  }\n  if (hasIndex) {\n    return [\n      'index.md',\n      ...sorted,\n    ]\n  }\n  if (hasFooter) {\n    return [\n      ...sorted,\n      'footer.md',\n    ]\n  }\n  return sorted\n}\n","import { join } from 'path'\nimport { createReadStream } from 'fs'\nimport { PassThrough } from 'stream'\nimport { debuglog } from 'util'\nimport readDirStructure from '@wrote/read-dir-structure'\nimport { getKeys } from './lib'\n\nconst LOG = debuglog('pedantry')\n\nconst processDir = async ({\n  stream, source, path = '.', content = {}, reverse = false,\n  separator, includeFilename, ignoreHidden,\n}) => {\n  const k = Object.keys(content)\n\n  const keys = getKeys(k, reverse)\n\n  const size = await keys.reduce(async (acc, name) => {\n    let totalSize = await acc\n    const { type, content: dirContent } = content[name]\n    const relPath = join(path, name)\n\n    let s\n    if (type == 'File') {\n      const shouldIgnore = ignoreHidden && name.startsWith('.')\n      if (!shouldIgnore) s = await processFile({\n        stream, source, path: relPath, separator, includeFilename,\n      })\n    } else if (type == 'Directory') {\n      s = await processDir({\n        stream, source, path: relPath, content: dirContent, reverse,\n        separator, includeFilename, ignoreHidden,\n      })\n    }\n    totalSize += s\n    return totalSize\n  }, 0)\n\n  LOG('dir %s size: %s B', path, size)\n  return size\n}\n\n/**\n * @param {Object} options\n * @param {Pedantry} options.stream\n */\nconst processFile = async (options) => {\n  const {\n    stream, source, path, separator, includeFilename,\n  } = options\n  const fullPath = join(source, path)\n  stream.emit('file', path)\n  if (separator && !stream.justStarted) {\n    if (includeFilename) {\n      stream.push({ file: 'separator', data: separator })\n    } else {\n      stream.push(separator)\n    }\n  }\n  const size = await new Promise((r, j) => {\n    let s = 0\n    const rs = createReadStream(fullPath)\n    rs.on('data', (d) => {\n      s += d.byteLength\n    }).on('error', (err) => {\n      j(err)\n    }).on('close', () => {\n      r(s)\n    })\n    if (includeFilename) {\n      rs.on('data', (data) => {\n        stream.push({ file: fullPath, data: `${data}` })\n      })\n    } else {\n      rs.pipe(stream, { end: false })\n    }\n  })\n  stream.justStarted = false\n  LOG('file %s :: %s B', fullPath, size)\n  return size\n}\n\n// * @todo implement reading only on read ie change mode\n\nexport default class Pedantry extends PassThrough {\n  /**\n   * Upon creation, `Pedantry` will start reading files in the `source` directory recursively in the following order: the content of the `index.md` file will go first, then of all files and directories in the folder recursively in a sorted order, and the content of the `footer.md` file will go last if found.\n   * @param {string} source Path to the root directory.\n   * @param {_pedantry.Options} [options] Options for Pedantry.\n   */\n  constructor(source, options = {}) {\n    const {\n      reverse = false,\n      addNewLine = false,\n      addBlankLine = false,\n      includeFilename = false,\n      ignoreHidden = false,\n    } = options\n    super({\n      objectMode: includeFilename,\n    })\n    let separator\n    if (addNewLine) separator = '\\n'\n    else if (addBlankLine) separator = '\\n\\n'\n    this.justStarted = true\n    ;(async () => {\n      let content\n      try {\n        ({ content } = await readDirStructure(source))\n      } catch (err) {\n        const e = new Error(err.message)\n        this.emit('error', e)\n      }\n      try {\n        await processDir({\n          stream: this,\n          source,\n          content,\n          reverse,\n          separator,\n          includeFilename,\n          ignoreHidden,\n        })\n      } catch (err) {\n        this.emit('error', err)\n      } finally {\n        this.end()\n      }\n    })()\n  }\n}\n\n// /**\n//  * A file event.\n//  * @event Pedantry#file\n//  * @param {string} file A path to the file currently being processed relative to the `Pedantry` source.\n//  */\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Options} _pedantry.Options\n */","import '../types/externs'\nimport Pedantry from './'\n\nmodule.exports = Pedantry"],
"names":["join","path","createReadStream","lstat","readdir","fs","PassThrough","stream","debuglog","util","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","checkArgumentIndex","i","makePromise","fn","resolveValue","er","fnLength","res","Promise","resolve","reject","err","error","allArgs","Array","isArray","forEach","arg","lstatFiles","dirPath","dirContent","readFiles","relativePath","ls","all","isDirectory","lstatRes","isNotDirectory","readDirStructure","code","dir","lsr","directories","files","notDirectories","reduce","acc","current","isFile","isSymbolicLink","type","dirs","structure","content","hasFile","array","file","some","a","getKeys","reverse","hasIndex","hasFooter","excluded","sorted","included","f","sort","b","localeCompare","numeric","LOG","processDir","separator","includeFilename","ignoreHidden","k","keys","size","name","totalSize","relPath","s","startsWith","processFile","options","fullPath","emit","justStarted","push","data","r","rs","on","d","byteLength","pipe","end","Pedantry","addNewLine","addBlankLine","objectMode","module","exports"]
}
